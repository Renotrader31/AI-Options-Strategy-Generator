<!DOCTYPE html>
<html>
<head>
    <title>Test Main App Logic</title>
    <link rel="icon" href="data:,">
</head>
<body>
    <h1>Testing Main App Data Flow</h1>
    <div id="results"></div>
    
    <script>
        // Copy the exact LiveDataManager class from main app
        class LiveDataManager {
            constructor() {
                this.apiConfig = {
                    POLYGON_API_KEY: '75rlu6cWGNnIqqR_x8M384YUjBgGk6kT',
                    FMP_API_KEY: 'm2XfxOS0sZxs6hLEY5yRzUgDyp5Dur4V',
                    ORTEX_API_KEY: 'Q0VpvWFI.wPuSEG6CNr7uoRZbtFcmVeeXpoJvjz75',
                    UNUSUAL_WHALES_API_KEY: '29a464c8-9da0-490a-ac24-0d4aa492dcbd'
                };
                
                this.cache = new Map();
                this.cacheTimeout = 30 * 1000; // 30 seconds cache
                
                console.log('üìä Live Data Manager initialized');
                this.showApiStatus();
            }
            
            showApiStatus() {
                const hasPolygon = this.apiConfig.POLYGON_API_KEY !== 'YOUR_POLYGON_API_KEY_HERE';
                const hasFMP = this.apiConfig.FMP_API_KEY !== 'YOUR_FMP_API_KEY_HERE';
                
                console.log('üîå API Status:');
                console.log(`  Polygon: ${hasPolygon ? '‚úÖ Configured' : '‚ùå Not configured'}`);
                console.log(`  FMP: ${hasFMP ? '‚úÖ Configured' : '‚ùå Not configured'}`);
                
                return { hasPolygon, hasFMP };
            }

            async getComprehensiveStockData(ticker) {
                try {
                    console.log(`üîç Fetching comprehensive data for ${ticker}...`);
                    
                    // Try to get live data first
                    const liveData = await this.getLiveStockData(ticker);
                    if (liveData && liveData.isRealData) {
                        console.log(`‚úÖ Using LIVE data for ${ticker}`);
                        return liveData;
                    }
                    
                } catch (error) {
                    console.error('‚ùå Live data fetch failed:', error);
                }
                
                // Fall back to enhanced mock data
                console.log(`üìä Using MOCK data for ${ticker}`);
                return this.generateEnhancedMockData(ticker);
            }
            
            async getLiveStockData(ticker) {
                const cacheKey = `stock_${ticker.toUpperCase()}`;
                
                // Check cache first
                if (this.cache.has(cacheKey)) {
                    const cached = this.cache.get(cacheKey);
                    if (Date.now() - cached.timestamp < this.cacheTimeout) {
                        console.log(`üîÑ Using cached data for ${ticker}`);
                        return cached.data;
                    }
                }
                
                try {
                    // Try Polygon first, then FMP
                    let data = null;
                    
                    try {
                        data = await this.getPolygonData(ticker);
                        console.log(`üéØ Polygon data retrieved for ${ticker}`);
                    } catch (polygonError) {
                        console.log(`‚ö†Ô∏è Polygon failed, trying FMP: ${polygonError.message}`);
                        try {
                            data = await this.getFMPData(ticker);
                            console.log(`üéØ FMP data retrieved for ${ticker}`);
                        } catch (fmpError) {
                            console.log(`‚ö†Ô∏è FMP also failed: ${fmpError.message}`);
                            throw new Error('Both APIs failed');
                        }
                    }
                    
                    // Cache the result
                    this.cache.set(cacheKey, {
                        data: data,
                        timestamp: Date.now()
                    });
                    
                    return data;
                    
                } catch (error) {
                    console.error('‚ùå Data fetch failed:', error);
                    return this.generateEnhancedMockData(ticker);
                }
            }
            
            async getPolygonData(ticker) {
                const apiKey = this.apiConfig.POLYGON_API_KEY;
                if (!apiKey || apiKey === 'YOUR_POLYGON_API_KEY_HERE') {
                    throw new Error('Polygon API key not configured');
                }
                
                const response = await fetch(
                    `https://api.polygon.io/v2/aggs/ticker/${ticker.toUpperCase()}/prev?adjusted=true&apikey=${apiKey}`
                );
                
                if (!response.ok) {
                    throw new Error(`Polygon API error: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (!data.results || data.results.length === 0) {
                    throw new Error('No Polygon data available for this ticker');
                }
                
                const result = data.results[0];
                const changeValue = result.c - result.o;
                const changePercent = (changeValue / result.o) * 100;
                
                return {
                    symbol: ticker.toUpperCase(),
                    currentPrice: result.c,
                    change: changeValue,
                    changePercent: changePercent,
                    volume: result.v,
                    high: result.h,
                    low: result.l,
                    open: result.o,
                    source: 'Polygon.io',
                    isRealData: true,
                    timestamp: new Date(result.t)
                };
            }
            
            async getFMPData(ticker) {
                const apiKey = this.apiConfig.FMP_API_KEY;
                if (!apiKey || apiKey === 'YOUR_FMP_API_KEY_HERE') {
                    throw new Error('FMP API key not configured');
                }
                
                const response = await fetch(
                    `https://financialmodelingprep.com/api/v3/quote/${ticker.toUpperCase()}?apikey=${apiKey}`
                );
                
                if (!response.ok) {
                    throw new Error(`FMP API error: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (!data || data.length === 0) {
                    throw new Error('No FMP data available for this ticker');
                }
                
                const result = data[0];
                
                return {
                    symbol: ticker.toUpperCase(),
                    currentPrice: result.price,
                    change: result.change,
                    changePercent: result.changesPercentage,
                    volume: result.volume || 0,
                    high: result.dayHigh || result.price,
                    low: result.dayLow || result.price,
                    open: result.open || result.price,
                    source: 'Financial Modeling Prep',
                    isRealData: true,
                    timestamp: new Date()
                };
            }
            
            generateEnhancedMockData(ticker) {
                // Enhanced mock data with realistic market characteristics
                const basePrice = 100 + Math.random() * 400;
                const volatility = 0.02 + Math.random() * 0.08;
                const trend = (Math.random() - 0.5) * 2;
                
                const change = basePrice * volatility * trend;
                const currentPrice = basePrice + change;
                const changePercent = (change / basePrice) * 100;
                
                return {
                    symbol: ticker.toUpperCase(),
                    currentPrice: parseFloat(currentPrice.toFixed(2)),
                    change: parseFloat(change.toFixed(2)),
                    changePercent: parseFloat(changePercent.toFixed(2)),
                    volume: Math.floor(Math.random() * 10000000),
                    high: parseFloat((currentPrice + Math.abs(change) * 0.5).toFixed(2)),
                    low: parseFloat((currentPrice - Math.abs(change) * 0.5).toFixed(2)),
                    open: parseFloat(basePrice.toFixed(2)),
                    source: 'Enhanced Mock Data',
                    isRealData: false,
                    timestamp: new Date()
                };
            }
        }

        // Test the data manager
        async function testDataManager() {
            const results = document.getElementById('results');
            
            try {
                const liveDataManager = new LiveDataManager();
                
                results.innerHTML += '<h2>Testing AAPL data fetch...</h2>';
                
                const aaplData = await liveDataManager.getComprehensiveStockData('AAPL');
                
                results.innerHTML += `
                    <h3>Result:</h3>
                    <p><strong>Symbol:</strong> ${aaplData.symbol}</p>
                    <p><strong>Price:</strong> $${aaplData.currentPrice}</p>
                    <p><strong>Change:</strong> ${aaplData.change} (${aaplData.changePercent}%)</p>
                    <p><strong>Source:</strong> ${aaplData.source}</p>
                    <p><strong>Data Type:</strong> ${aaplData.isRealData ? 'üî¥ LIVE' : 'üìä MOCK'}</p>
                    <p><strong>Volume:</strong> ${aaplData.volume?.toLocaleString()}</p>
                `;
                
                console.log('Full data object:', aaplData);
                
            } catch (error) {
                console.error('Test failed:', error);
                results.innerHTML += `<p style="color: red;">‚ùå Test failed: ${error.message}</p>`;
            }
        }
        
        // Run test
        testDataManager();
    </script>
</body>
</html>